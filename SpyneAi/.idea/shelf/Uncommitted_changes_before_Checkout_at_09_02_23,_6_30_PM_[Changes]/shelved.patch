Index: app/src/main/res/layout/fragment_camera.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:background=\"@android:color/black\"\n    android:keepScreenOn=\"true\">\n\n\n    <androidx.camera.view.PreviewView\n        android:id=\"@+id/viewFinder\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintDimensionRatio=\"3:4\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        android:layout_marginTop=\"?attr/actionBarSize\"\n        app:layout_constraintTop_toTopOf=\"parent\" >\n\n        <com.spyneai.shoot.ui.base.GyroView\n            android:id=\"@+id/flLevelIndicator\"\n            android:layout_width=\"0dp\"\n            android:layout_height=\"0dp\"\n            android:background=\"@android:color/transparent\" />\n    </androidx.camera.view.PreviewView>\n\n    <LinearLayout\n        android:id=\"@+id/llCapture\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"0dp\"\n        android:background=\"@color/black\"\n        android:gravity=\"center\"\n        android:orientation=\"horizontal\"\n        android:padding=\"@dimen/dp_10\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\">\n\n        <LinearLayout\n            android:layout_width=\"0dp\"\n            android:layout_height=\"wrap_content\"\n            android:layout_weight=\"1\"\n            android:gravity=\"center\"\n            android:padding=\"@dimen/dp_5\">\n\n            <androidx.cardview.widget.CardView\n                android:id=\"@+id/cardOverlay\"\n                android:layout_width=\"@dimen/dp_50\"\n                android:layout_height=\"@dimen/dp_50\"\n                app:cardCornerRadius=\"@dimen/dp_50\">\n\n                <ImageView\n                    android:id=\"@+id/ivPreview\"\n                    android:layout_width=\"@dimen/dp_50\"\n                    android:layout_height=\"@dimen/dp_50\"\n                    android:fontFamily=\"@font/bold\"\n                    android:gravity=\"center\"\n                    android:background=\"@color/black\"\n                    android:padding=\"@dimen/sp_5\" />\n            </androidx.cardview.widget.CardView>\n        </LinearLayout>\n\n        <ImageView\n            android:id=\"@+id/cameraCaptureButton\"\n            android:layout_width=\"0dp\"\n            android:layout_height=\"wrap_content\"\n            android:layout_weight=\"1\"\n            android:elevation=\"2dp\"\n            android:src=\"@drawable/click_effect\" />\n\n        <LinearLayout\n            android:layout_width=\"0dp\"\n            android:layout_height=\"wrap_content\"\n            android:layout_weight=\"1\"\n            android:gravity=\"center\">\n\n            <com.mikhaellopez.circularimageview.CircularImageView\n                android:id=\"@+id/ivEndProject\"\n                android:layout_width=\"@dimen/dp_50\"\n                android:layout_height=\"@dimen/dp_50\"\n                android:gravity=\"center\"\n                android:visibility=\"invisible\"\n                android:src=\"@drawable/ic_end_project\" />\n        </LinearLayout>\n    </LinearLayout>\n\n    <com.spyneai.camera2.TapFocusExposure\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        android:id=\"@+id/flTapToFocus\"\n        app:layout_constraintBottom_toBottomOf=\"@id/viewFinder\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"@id/viewFinder\">\n    </com.spyneai.camera2.TapFocusExposure>\n\n    <LinearLayout\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\"\n        android:background=\"@drawable/setting_bg\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        android:layout_margin=\"@dimen/dp_10\"\n        app:layout_constraintLeft_toLeftOf=\"parent\">\n\n        <LinearLayout\n            android:id=\"@+id/llSetting\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:paddingVertical=\"@dimen/dp_5\"\n            android:background=\"@color/setting\"\n            android:orientation=\"horizontal\"\n            android:clickable=\"true\">\n\n            <ImageView\n                android:layout_width=\"@dimen/dp_25\"\n                android:layout_height=\"@dimen/dp_25\"\n                android:layout_weight=\"1\"\n                android:layout_gravity=\"center_vertical\"\n                android:src=\"@drawable/setting\" />\n            <TextView\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Settings\"\n                android:layout_weight=\"1\"\n                android:visibility=\"gone\"\n                android:layout_gravity=\"center_vertical\"\n                android:textSize=\"@dimen/sp_16\"\n                android:layout_marginLeft=\"@dimen/dp_5\"\n                android:textColor=\"@color/white\"\n                android:fontFamily=\"@font/poppins_medium\"/>\n            <ImageView\n                android:id=\"@+id/ivCross\"\n                android:layout_width=\"@dimen/dp_15\"\n                android:layout_height=\"@dimen/dp_25\"\n                android:visibility=\"gone\"\n                android:layout_gravity=\"center_vertical\"\n                android:layout_marginRight=\"10dp\"\n                android:layout_marginLeft=\"@dimen/dp_10\"\n                android:src=\"@drawable/cross\">\n            </ImageView>\n        </LinearLayout>\n\n        <LinearLayout\n            android:id=\"@+id/llShowOverlay\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:padding=\"10dp\"\n            android:visibility=\"gone\"\n            android:background=\"@color/setting_item\"\n            android:orientation=\"horizontal\">\n\n            <TextView\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Show Overlay\"\n                android:layout_weight=\"1\"\n                android:textColor=\"@color/white\"\n                android:textSize=\"@dimen/sp_16\"\n                android:fontFamily=\"@font/poppins_medium\"/>\n\n            <Switch\n                android:id=\"@+id/switchShowOverlay\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:layout_marginLeft=\"@dimen/dp_15\"></Switch>\n\n        </LinearLayout>\n\n        <LinearLayout\n            android:id=\"@+id/llShowGrid\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:padding=\"10dp\"\n            android:visibility=\"gone\"\n            android:background=\"@color/setting_item\"\n            android:orientation=\"horizontal\">\n\n            <TextView\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Show Camera Grid\"\n                android:textColor=\"@color/white\"\n                android:layout_weight=\"1\"\n                android:textSize=\"@dimen/sp_16\"\n                android:fontFamily=\"@font/poppins_medium\"/>\n            <Switch\n                android:id=\"@+id/switchShowGrid\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:layout_marginLeft=\"@dimen/dp_15\"></Switch>\n\n        </LinearLayout>\n        <LinearLayout\n            android:id=\"@+id/llShowGyro\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:padding=\"10dp\"\n            android:visibility=\"gone\"\n            android:background=\"@color/setting_item\"\n            android:orientation=\"horizontal\">\n\n            <TextView\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:fontFamily=\"@font/poppins_medium\"\n                android:text=\"Show Gyrometer\"\n                android:layout_weight=\"1\"\n                android:textColor=\"@color/white\"\n                android:textSize=\"@dimen/sp_16\" />\n\n            <Switch\n                android:id=\"@+id/switchShowGyro\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:layout_marginLeft=\"@dimen/dp_15\"></Switch>\n\n        </LinearLayout>\n    </LinearLayout>\n\n\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        android:textSize=\"@dimen/sp_25\"\n        android:visibility=\"gone\"\n        android:textColor=\"@color/primary\"\n        android:id=\"@+id/tvPitchRoll\"\n        android:text=\"Sandeep Singh\"/>\n\n    <LinearLayout\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"horizontal\"\n        android:layout_marginHorizontal=\"@dimen/dp_10\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        android:layout_marginTop=\"@dimen/dp_5\"\n        android:visibility=\"gone\"\n        app:layout_constraintTop_toTopOf=\"@id/viewFinder\"\n        app:layout_constraintLeft_toLeftOf=\"parent\">\n\n        <TextView\n            android:id=\"@+id/tvPitch\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_weight=\"1\"\n            android:textSize=\"@dimen/sp_16\"\n            android:textColor=\"@color/white\"></TextView>\n\n        <TextView\n            android:id=\"@+id/tvRoll\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:gravity=\"right\"\n            android:layout_weight=\"1\"\n            android:textSize=\"@dimen/sp_20\"\n            android:textColor=\"@color/white\"></TextView>\n\n    </LinearLayout>\n    <LinearLayout\n        android:id=\"@+id/llSKuName\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:gravity=\"center\"\n        android:elevation=\"@dimen/dp_10\"\n        android:layout_marginTop=\"@dimen/dp_10\"\n        android:paddingVertical=\"@dimen/dp_10\"\n        android:paddingHorizontal=\"@dimen/dp_15\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        android:background=\"@drawable/bg_edit\">\n\n        <TextView\n            android:id=\"@+id/tvSkuN\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:fontFamily=\"@font/medium\"\n            android:gravity=\"center\"\n            android:hint=\"sku name\"\n            android:maxLines=\"1\"\n            android:maxLength=\"20\"\n            android:textColor=\"@color/white\"\n            android:textColorHint=\"@color/white\"\n            android:textSize=\"@dimen/sp_13\" />\n\n        <ImageView\n            android:id=\"@+id/ivEditSku\"\n            android:layout_width=\"@dimen/dp_15\"\n            android:layout_height=\"@dimen/dp_15\"\n            android:layout_marginLeft=\"@dimen/dp_10\"\n            android:src=\"@drawable/pencil\"\n            app:tint=\"@color/white\">\n        </ImageView>\n\n\n    </LinearLayout>\n\n\n</androidx.constraintlayout.widget.ConstraintLayout>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/layout/fragment_camera.xml b/app/src/main/res/layout/fragment_camera.xml
--- a/app/src/main/res/layout/fragment_camera.xml	
+++ b/app/src/main/res/layout/fragment_camera.xml	
@@ -20,8 +20,8 @@
 
         <com.spyneai.shoot.ui.base.GyroView
             android:id="@+id/flLevelIndicator"
-            android:layout_width="0dp"
-            android:layout_height="0dp"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
             android:background="@android:color/transparent" />
     </androidx.camera.view.PreviewView>
 
Index: app/src/main/java/com/spyneai/shoot/ui/base/CameraFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\nimport android.annotation.SuppressLint\nimport android.app.Activity\nimport android.content.ContentValues\nimport android.content.Context\nimport android.content.pm.ActivityInfo\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.os.Build\nimport android.os.Bundle\nimport android.os.Environment\nimport android.os.Handler\nimport android.provider.MediaStore\nimport android.text.Layout\nimport android.text.Spannable\nimport android.text.SpannableString\nimport android.text.style.AlignmentSpan\nimport android.util.DisplayMetrics\nimport android.util.Log\nimport android.util.Size\nimport android.view.LayoutInflater\nimport android.view.Surface.ROTATION_90\nimport android.view.View\nimport android.view.View.GONE\nimport android.view.View.VISIBLE\nimport android.view.ViewGroup\nimport android.view.ViewTreeObserver\nimport android.widget.Toast\nimport androidx.camera.camera2.internal.compat.workaround.TargetAspectRatio.RATIO_4_3\nimport androidx.camera.core.*\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.core.content.ContextCompat\nimport androidx.core.net.toFile\nimport com.hbisoft.pickit.PickiT\nimport com.hbisoft.pickit.PickiTCallbacks\nimport com.spyneai.R\nimport com.spyneai.app.BaseApplication\nimport com.spyneai.aspectRatio\nimport com.spyneai.base.BaseFragment\nimport com.spyneai.camera2.ShootDimensions\nimport com.spyneai.databinding.FragmentCameraBinding\nimport com.spyneai.needs.AppConstants\nimport com.spyneai.needs.Utilities\nimport com.spyneai.posthog.Events\nimport com.spyneai.posthog.captureEvent\nimport com.spyneai.posthog.captureFailureEvent\nimport com.spyneai.shoot.data.ShootViewModel\nimport com.spyneai.shoot.data.model.ShootData\nimport com.spyneai.shoot.ui.dialogs.CreateProjectAndSkuDialog\nimport com.spyneai.shoot.ui.dialogs.CreateSkuDialog\nimport com.spyneai.shoot.ui.dialogs.ShootExitDialog\nimport com.spyneai.shoot.ui.ecomwithgrid.dialogs.CreateSkuEcomDialog\nimport com.spyneai.shoot.ui.ecomwithgrid.dialogs.ProjectTagDialog\nimport com.spyneai.shoot.utils.log\nimport com.spyneai.shoot.utils.shoot\nimport org.json.JSONObject\nimport java.io.File\nimport java.util.concurrent.ExecutionException\nimport java.util.concurrent.ExecutorService\nimport java.util.concurrent.Executors\nimport kotlin.math.abs\nimport kotlin.math.roundToInt\n\n\nclass CameraFragment() : BaseFragment<ShootViewModel, FragmentCameraBinding>(), PickiTCallbacks,\n    SensorEventListener {\n    private var imageCapture: ImageCapture? = null\n\n    private var imageAnalyzer: ImageAnalysis? = null\n\n    private lateinit var cameraExecutor: ExecutorService\n    var pickIt: PickiT? = null\n    private val FILENAME_FORMAT = \"yyyy-MM-dd-HH-mm-ss-SSS\"\n    private var flashMode: Int = ImageCapture.FLASH_MODE_OFF\n\n    // Selector showing which camera is selected (front or back)\n    private var lensFacing = CameraSelector.DEFAULT_BACK_CAMERA\n    lateinit var file: File\n    var haveGyrometer = false\n    var isSensorAvaliable = false\n    var rotation = 0\n    var end: Long = 0\n    var begin: Long = 0\n    var mid: Long = 0\n    var angle = 0\n    var upcomingAngle = 0\n\n    var skuCount=0\n\n\n    private var pitch = 0.0\n    var roll = 0.0\n    var azimuth = 0.0\n\n    private lateinit var mSensorManager: SensorManager\n    private var mAccelerometer: Sensor? = null\n    private val accelerometerReading = FloatArray(3)\n    private val magnetometerReading = FloatArray(3)\n\n    private val rotationMatrix = FloatArray(9)\n    private val orientationAngles = FloatArray(3)\n\n    private var cameraControl: CameraControl? = null\n    private var cameraInfo: CameraInfo? = null\n    private var handler: Handler? = null\n\n    private var filename = \"\"\n\n    var gravity = FloatArray(3)\n    val TAG = \"Camera Fragment\"\n\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        mSensorManager = requireActivity().getSystemService(Context.SENSOR_SERVICE) as SensorManager\n        mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD)\n//        binding.tvSkuN!!.text = viewModel.sku!!.skuName\n\n        handler  = Handler()\n\n        val activity: Activity? = activity\n\n        handler!!.postDelayed({\n            if (activity != null)\n                startCamera()\n        }, 300)\n\n        cameraExecutor = Executors.newSingleThreadExecutor()\n        // Determine the output direcrotory\n        pickIt = PickiT(requireContext(), this, requireActivity())\n\n\n        binding.ivBack?.setOnClickListener {\n            ShootExitDialog().show(requireActivity().supportFragmentManager, \"CameraFragment\")\n        }\n\n\n        viewModel.startInteriorShots.observe(viewLifecycleOwner) {\n            if (it) {\n                binding.llSKuName!!.isClickable=false\n                binding.ivEditSku!!.visibility=View.GONE\n                binding.switchShowOverlay?.isChecked = false\n                binding.switchShowGyro?.isChecked = false\n                binding.switchShowOverlay?.isClickable = false\n                binding.switchShowGyro?.isClickable = false\n                viewModel.showLeveler.value = false\n                binding.tvSkipShoot?.text = getString(R.string.miscshoots)\n                binding.llSkip?.visibility = View.VISIBLE\n            }\n        }\n\n        viewModel.imageTypeInfo.observe(viewLifecycleOwner) {\n            if (it) {\n                startCamera()\n            }\n        }\n        viewModel.isSkuNameAdded.observe(viewLifecycleOwner) {\n            if (it) {\n                binding.llSKuName.isClickable = true\n//                viewModel.isSkuNameAdded.value=false\n                binding.tvSkuN!!.text= viewModel.sku!!.skuName\n            }\n        }\n\n        refreshText()\n\n        if(viewModel.shootList.value==null){\n            binding.llSKuName!!.isClickable=true\n            binding.ivEditSku!!.visibility=View.VISIBLE\n        }else{\n            binding.llSKuName!!.isClickable=false\n            binding.ivEditSku!!.visibility=View.GONE\n        }\n\n        viewModel.isProjectNameEdited.observe(viewLifecycleOwner) {\n            if (it) {\n                binding.llSKuName!!.isClickable = false\n                binding.ivEditSku!!.visibility = View.GONE\n                binding.tvSkuN!!.text = viewModel.sku!!.skuName\n            } else {\n                binding.llSKuName!!.isClickable = true\n                binding.ivEditSku!!.visibility = View.VISIBLE\n            }\n        }\n\n        if(viewModel.isReshoot) {\n            binding.llSKuName!!.isClickable=false\n            binding.ivEditSku!!.visibility=View.GONE\n            binding.tvSkuN!!.text= viewModel.sku!!.skuName\n        }\n\n        checkSensor()\n\n        viewModel.startMiscShots.observe(viewLifecycleOwner) {\n            if (it) {\n                binding.llSKuName!!.isClickable=false\n                binding.ivEditSku!!.visibility=View.GONE\n                binding.switchShowOverlay?.isChecked = false\n                binding.switchShowGyro?.isChecked = false\n                binding.switchShowOverlay?.isClickable = false\n                binding.switchShowGyro?.isClickable = false\n                viewModel.showLeveler.value = false\n                if (getString(R.string.app_name) == AppConstants.OLA_CABS) {\n                    binding.tvSkipShoot?.text = getString(R.string.three_sixty_int)\n                } else {\n                    binding.tvSkipShoot?.text = getString(R.string.end_shoot_karvi)\n                }\n                binding.llSkip?.visibility = View.VISIBLE\n            }\n\n        }\n\n        viewModel.showLeveler.observe(viewLifecycleOwner) {\n            Log.d(TAG, \"onViewCreated: gyro $it\")\n            if (it && isSensorAvaliable) {\n                val cameraSettings =\n                    if (viewModel.subcategoryV2?.cameraSettings == null)\n                        viewModel.category?.cameraSettingsV2\n                    else\n                        viewModel.subcategoryV2?.cameraSettings\n\n                binding.flLevelIndicator.visibility = View.VISIBLE\n//                Log.d(TAG, \"orientation: \"+viewModel.category?.orientation!!)\n                val s=\"\"\n                viewModel.category?.orientation?.let { orientation ->\n                    cameraSettings?.let { a ->\n                        binding.flLevelIndicator.start(orientation,a)\n                    }\n                }\n            } else {\n                binding.flLevelIndicator.visibility = View.GONE\n            }\n        }\n\n        viewModel.showGrid.observe(viewLifecycleOwner) {\n            if (it) {\n                binding.groupGridLines?.visibility = View.VISIBLE\n            } else binding.groupGridLines?.visibility = View.INVISIBLE\n        }\n\n        if (getString(R.string.app_name) == AppConstants.KARVI) {\n            binding.tvSkipShoot?.setTextColor(\n                ContextCompat.getColor(\n                    requireContext(),\n                    R.color.secondary\n                )\n            )\n            binding.ivSkip?.setColorFilter(\n                ContextCompat.getColor(requireContext(), R.color.secondary),\n                android.graphics.PorterDuff.Mode.MULTIPLY\n            );\n        }\n\n\n        binding.llSKuName.setOnClickListener {\n            binding.llSKuName.isClickable = false\n            if (viewModel.category?.orientation == \"portrait\") {\n                Log.d(TAG, \"sku count camera: \"+viewModel.skuCount)\n\n                if(viewModel.skuCount>1){\n                    CreateSkuEcomDialog().show(\n                        requireActivity().supportFragmentManager,\n                        \"Camera Fragment\"\n                    )\n                } else{\n                    ProjectTagDialog().show(\n                        requireActivity().supportFragmentManager,\n                        \"Camera Fragment\"\n                    )\n                }\n\n            } else {\n                if(viewModel.skuCount>1){\n                    CreateSkuDialog().show(\n                        requireActivity().supportFragmentManager,\n                        \"Camera Fragment\"\n                    )\n                } else{\n                    CreateProjectAndSkuDialog().show(\n                        requireActivity().supportFragmentManager,\n                        \"Camera Fragment\"\n                    )\n                }\n            }\n        }\n\n        binding.cameraCaptureButton.setOnClickListener {\n\n            onCaptureClick()\n            viewModel.pointAngle.value = true\n        }\n\n        binding.tvSkipShoot?.setOnClickListener {\n            viewModel.skipImage(getString(R.string.app_name))\n        }\n\n        viewModel.onVolumeKeyPressed.observe(viewLifecycleOwner) {\n            viewModel.sku?.let {\n                if (it.isSelectAble)\n                    onCaptureClick()\n            }\n        }\n\n        //camera setting\n        if (viewModel.category?.orientation == \"landscape\" || viewModel.category?.orientation == \"portrait\") {\n            viewModel.showGrid.value = viewModel.getCameraSetting().isGridActive\n            // viewModel.showLeveler.value = viewModel.getCameraSetting().isGryroActive\n            viewModel.showOverlay.value = viewModel.getCameraSetting().isOverlayActive\n\n            binding.llSetting.setOnClickListener {\n                if (viewModel.categoryDetails.value?.imageType == \"Info\" ||\n                    viewModel.categoryDetails.value?.imageType == \"Misc\" ||\n                    viewModel.categoryDetails.value?.imageType == \"Interior\" ||\n                    viewModel.categoryDetails.value?.imageType == \"Focus Shoot\"\n                ) {\n                    binding.switchShowOverlay?.isChecked = false\n                    binding.switchShowGyro?.isChecked = false\n                    binding.switchShowOverlay?.isClickable = false\n                    binding.switchShowGyro?.isClickable = false\n                } else {\n                    binding.switchShowOverlay?.isClickable = true\n                    binding.switchShowGyro.isClickable = true\n\n\n                }\n\n                if (viewModel.category?.orientation == \"portrait\" || getString(R.string.app_name) == AppConstants.SWIGGY\n                ) {\n\n                    if(viewModel.hasEcomOverlay){\n                    binding.switchShowOverlay?.isClickable = true\n                    }else {\n                        binding.switchShowOverlay?.isChecked = false\n                    binding.switchShowOverlay?.isClickable = false\n                    }\n                }\n\n                if ( viewModel.categoryDetails.value?.imageType == \"Info\") {\n                    binding.switchShowOverlay?.isChecked = false\n                    binding.switchShowOverlay?.isClickable = false\n                    binding.switchShowGyro?.isChecked = false\n                    binding.switchShowGyro?.isClickable = false\n                }\n                if (binding.ivCross?.visibility == GONE) {\n                    binding.ivCross?.visibility = VISIBLE\n                    binding.llShowOverlay?.visibility = VISIBLE\n                    binding.llShowGrid?.visibility = VISIBLE\n                    binding.llShowGyro?.visibility = VISIBLE\n                } else {\n                    binding.ivCross?.visibility = GONE\n                    binding.llShowOverlay?.visibility = GONE\n                    binding.llShowGrid?.visibility = GONE\n                    binding.llShowGyro?.visibility = GONE\n                }\n            }\n\n            binding.switchShowGyro?.isChecked = viewModel.getCameraSetting().isGryroActive\n\n            binding.switchShowGyro.setOnCheckedChangeListener { _, isChecked ->\n                if(viewModel.startInteriorShots.value!=true && viewModel.startMiscShots.value != true) {\n                    Utilities.saveBool(\n                        requireContext(),\n                        viewModel.category?.categoryId + AppConstants.SETTING_STATUS_GYRO,\n                        isChecked\n                    )\n                }\n                if (isChecked)\n                    viewModel.showLeveler.value = isChecked\n                else\n                    viewModel.showLeveler.value = false\n            }\n\n            binding.switchShowOverlay.isChecked = viewModel.getCameraSetting().isOverlayActive\n\n            binding.switchShowOverlay.setOnCheckedChangeListener { _, isChecked ->\n                if(viewModel.startInteriorShots.value!=true && viewModel.startMiscShots.value != true) {\n                    Utilities.saveBool(\n                        requireContext(),\n                        viewModel.category?.categoryId + AppConstants.SETTING_STATUS_OVERLAY,\n                        isChecked\n                    )\n                }\n                if (isChecked)\n                    viewModel.showOverlay.value = isChecked\n                else\n                    viewModel.showOverlay.value = false\n\n            }\n\n            binding.switchShowGrid?.isChecked = viewModel.getCameraSetting().isGridActive\n\n            binding.switchShowGrid.setOnCheckedChangeListener { _, isChecked ->\n                Utilities.saveBool(\n                    requireContext(),\n                    viewModel.category?.categoryId + AppConstants.SETTING_STATUS_GRID,\n                    isChecked\n                )\n                if (isChecked)\n                    viewModel.showGrid.value = isChecked\n                else\n                    viewModel.showGrid.value = false\n            }\n        }\n\n\n    }\n\n    fun checkSensor(){\n        val mAccelerometer =\n            mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)?.also { accelerometer ->\n                mSensorManager.registerListener(\n                    this,\n                    accelerometer,\n                    SensorManager.SENSOR_DELAY_NORMAL,\n                    SensorManager.SENSOR_DELAY_UI\n                )\n            }\n\n        val magneticField =\n            mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD)?.also { magneticField ->\n                mSensorManager.registerListener(\n                    this,\n                    magneticField,\n                    SensorManager.SENSOR_DELAY_NORMAL,\n                    SensorManager.SENSOR_DELAY_UI\n                )\n            }\n\n        if (mAccelerometer != null && magneticField != null)\n            isSensorAvaliable = true\n\n    }\n\n    override fun onResume() {\n        super.onResume()\n        shoot(\"onResume called(camera fragment)\")\n\n        checkSensor()\n    }\n\n    override fun onDestroy() {\n        mSensorManager.unregisterListener(this)\n        super.onDestroy()\n    }\n\n    private fun onCaptureClick() {\n        if (binding.flLevelIndicator.visibility == View.VISIBLE) {\n            if (binding.flLevelIndicator.isGyroOnCorrectAngle) {\n                captureImage()\n            } else {\n                showGryroToast()\n            }\n        } else {\n            captureImage()\n        }\n    }\n\n    private fun showGryroToast() {\n        val text = getString(R.string.level_gryometer)\n        val centeredText: Spannable = SpannableString(text)\n        centeredText.setSpan(\n            AlignmentSpan.Standard(Layout.Alignment.ALIGN_CENTER),\n            0, text.length - 1,\n            Spannable.SPAN_INCLUSIVE_INCLUSIVE\n        )\n\n        Toast.makeText(requireContext(), centeredText, Toast.LENGTH_LONG).show()\n    }\n\n    private fun captureImage() {\n        //ThreeSixtyInteriorHintDialog().show(requireActivity().supportFragmentManager,\"ThreeSixtyInteriorHintDialog\")\n        if (viewModel.isCameraButtonClickable) {\n            takePhoto()\n            log(\"shoot image button clicked\")\n            viewModel.isCameraButtonClickable = false\n        }\n    }\n\n    override fun setUserVisibleHint(isVisibleToUser: Boolean) {\n        super.setUserVisibleHint(isVisibleToUser)\n        if (isVisibleToUser) {\n            val a: Activity? = activity\n            if (a != null) a.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE\n        }\n    }\n\n\n    @SuppressLint(\"UnsafeOptInUsageError\")\n    private fun startCamera() {\n        val cameraProviderFuture = ProcessCameraProvider.getInstance(requireContext())\n        var cameraProvider: ProcessCameraProvider\n        cameraProviderFuture.addListener({\n\n            // Used to bind the lifecycle of cameras to the lifecycle owner\n            try {\n                cameraProvider = cameraProviderFuture.get()\n            } catch (e: InterruptedException) {\n                Log.d(TAG, \"startCamera: \" + e.message)\n                Toast.makeText(requireContext(), \"Error starting camera\", Toast.LENGTH_SHORT)\n                    .show()\n                return@addListener\n            } catch (e: ExecutionException) {\n                Log.d(TAG, \"startCamera: \" + e.message)\n                Toast.makeText(requireContext(), \"Error starting camera\", Toast.LENGTH_SHORT)\n                    .show()\n                return@addListener\n            }\n\n            // The display information\n            //val metrics = DisplayMetrics().also { binding.viewFinder.display.getRealMetrics(it) }\n            // The ratio for the output image and preview\n            var height = 0\n            var width = 0\n            val displayMetrics = DisplayMetrics()\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {\n                if (requireContext() != null) {\n                    requireContext().display?.getRealMetrics(displayMetrics)\n                    height = displayMetrics.heightPixels\n                    width = displayMetrics.widthPixels\n                }\n\n            } else {\n                if (requireActivity() != null) {\n                    requireActivity().windowManager.defaultDisplay.getMetrics(displayMetrics)\n                    height = displayMetrics.heightPixels\n                    width = displayMetrics.widthPixels\n                }\n            }\n            val aspectRatio = aspectRatio(width, height,getString(R.string.app_name))\n            // The display rotation\n            //val rotation = binding.viewFinder.display.rotation\n\n            val localCameraProvider = cameraProvider\n                ?: throw IllegalStateException(\"Camera initialization failed.\")\n            var size = Size(1024, 768)\n            var automobileResolution = Size(1920, 1080)\n            var portrait = Size(2048, 1536)\n\n            // Preview\n            val preview = when (viewModel.category?.orientation) {\n                \"landscape\" -> {\n                    if (getString(R.string.app_name) == AppConstants.KARVI) {\n                        Preview.Builder()\n                            .setTargetResolution(size)\n                            .build()\n                            .also {\n                                it.setSurfaceProvider(binding.viewFinder.surfaceProvider)\n                            }\n                    }\n                    else{\n                        Preview.Builder()\n                            .setTargetResolution(automobileResolution)\n                            .build()\n                            .also {\n                                it.setSurfaceProvider(binding.viewFinder.surfaceProvider)\n                            }\n                    }\n                }\n                else -> {\n                    Preview.Builder()\n                        .setTargetAspectRatio(AspectRatio.RATIO_4_3)\n                        .build()\n                        .also {\n                            it.setSurfaceProvider(binding.viewFinder.surfaceProvider)\n                        }\n                }\n\n            }\n\n            imageCapture = when (viewModel.category?.orientation) {\n                \"landscape\" -> {\n                    if (getString(R.string.app_name) == AppConstants.KARVI) {\n                        ImageCapture.Builder()\n                            .setCaptureMode(ImageCapture.CAPTURE_MODE_MAXIMIZE_QUALITY)\n                            .setFlashMode(flashMode)\n                            .setTargetResolution(size)\n                            .build()\n                    }\n                    else{\n                        ImageCapture.Builder()\n                            .setCaptureMode(ImageCapture.CAPTURE_MODE_MAXIMIZE_QUALITY)\n                            .setFlashMode(flashMode)\n                            .setTargetResolution(automobileResolution)\n                            .build()\n                    }\n                }\n                else -> {\n                    if (viewModel.categoryDetails.value?.imageType == \"Info\") {\n                        ImageCapture.Builder()\n                            .setCaptureMode(ImageCapture.CAPTURE_MODE_MAXIMIZE_QUALITY)\n                            .setFlashMode(flashMode)\n                            .setTargetAspectRatio(RATIO_4_3)\n//                            .setTargetResolution(portrait)\n                            .build()\n\n                    } else {\n                        ImageCapture.Builder()\n                            .setCaptureMode(ImageCapture.CAPTURE_MODE_MAXIMIZE_QUALITY)\n                            .setFlashMode(flashMode)\n                            .setTargetResolution(portrait)\n                            .setTargetRotation(ROTATION_90)\n                            .build()\n                    }\n                }\n\n            }\n\n            val useCaseGroup = UseCaseGroup.Builder()\n                .addUseCase(preview)\n                .addUseCase(imageCapture!!)\n                .build()\n\n\n            // Select back camera as a default\n            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n\n\n            // Unbind use cases before rebinding\n            cameraProvider.unbindAll()\n            try {\n                // Bind use cases to camera\n                val camera = cameraProvider.bindToLifecycle(\n                    viewLifecycleOwner,\n                    cameraSelector,\n                    useCaseGroup\n                )\n\n                cameraControl = camera.cameraControl\n\n                cameraInfo = camera.cameraInfo\n\n                if (viewModel.category?.orientation == \"landscape\"){\n                    var currentZoomRatio = cameraInfo?.zoomState?.value?.zoomRatio ?: 0F\n                    cameraControl?.setZoomRatio(currentZoomRatio * 1.3F)\n                }\n\n                if (viewModel.shootDimensions.value == null ||\n                    viewModel.shootDimensions.value?.previewHeight == 0\n                ) {\n                    getPreviewDimensions(binding.viewFinder!!, 0)\n                }\n            } catch (exc: Exception) {\n                Log.e(TAG, \"Use case binding failed\", exc)\n                val properties = HashMap<String, Any?>()\n                properties[\"error\"] = exc?.localizedMessage\n                properties[\"category\"] = viewModel.categoryDetails.value?.categoryName\n\n                BaseApplication.getContext().captureEvent(\n                    Events.OVERLAY_CAMERA_FIALED,\n                    properties\n                )\n            }\n\n        }, ContextCompat.getMainExecutor(requireContext()))\n\n    }\n\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        shoot(\"onDestroyView called(overlay fragment)\")\n\n        // Shut down our background executor\n        cameraExecutor.shutdown()\n\n    }\n\n\n    private fun takePhoto() {\n        begin = System.currentTimeMillis()\n        viewModel.begin.value = begin\n        // Get a stable reference of the modifiable image capture use case\n        val imageCapture1 = imageCapture ?: return\n\n\n        // Setup image capture metadata\n        val metadata = ImageCapture.Metadata().apply {\n            // Mirror image when using the front camera\n            isReversedHorizontal = lensFacing == CameraSelector.DEFAULT_FRONT_CAMERA\n        }\n\n        // The Folder location where all the files will be stored\n        val outputDirectory: String by lazy {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n                \"${Environment.DIRECTORY_DCIM}/Spyne/${viewModel.project?.projectName}-${viewModel.sku?.projectUuid}/${viewModel.sku?.skuName}-${viewModel.sku?.uuid}/\"\n            } else {\n                \"${Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM)}/Spyne/${viewModel.project?.projectName}-${viewModel.sku?.projectUuid}/${viewModel.sku?.skuName}-${viewModel.sku?.uuid}/\"\n            }\n        }\n\n        filename = viewModel.getFileName(\n            requireActivity().intent.getIntExtra(AppConstants.INTERIOR_SIZE, 0),\n            requireActivity().intent.getIntExtra(AppConstants.MISC_SIZE, 0)\n        )\n\n        // Options fot the output image file\n        val outputOptions = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n            val contentValues = ContentValues().apply {\n                put(MediaStore.MediaColumns.DISPLAY_NAME, filename)\n                put(MediaStore.MediaColumns.MIME_TYPE, \"image/jpeg\")\n                put(MediaStore.MediaColumns.RELATIVE_PATH, outputDirectory)\n            }\n\n            val contentResolver = requireContext().contentResolver\n\n            // Create the output uri\n            val contentUri =\n                MediaStore.Images.Media.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)\n\n            ImageCapture.OutputFileOptions.Builder(contentResolver, contentUri, contentValues)\n        } else {\n            File(outputDirectory).mkdirs()\n            file = File(outputDirectory, \"${filename}.jpg\")\n\n            ImageCapture.OutputFileOptions.Builder(file)\n        }.setMetadata(metadata).build()\n\n\n        // Set up image capture listener, which is triggered after photo has\n        // been taken\n        imageCapture1.takePicture(\n            outputOptions,\n            ContextCompat.getMainExecutor(requireContext()),\n            object : ImageCapture.OnImageSavedCallback {\n                override fun onError(exc: ImageCaptureException) {\n                    viewModel.isCameraButtonClickable = true\n                    log(\"Photo capture failed: \" + exc.message)\n\n                    try {\n                        Toast.makeText(\n                            requireContext(),\n                            \"Photo capture failed: \" + exc.message,\n                            Toast.LENGTH_LONG\n                        ).show()\n                    } catch (e: Exception) {\n\n                    }\n\n                    Utilities.hideProgressDialog()\n\n                    BaseApplication.getContext().captureFailureEvent(\n                        Events.IMAGE_CAPRURE_FAILED,\n                        HashMap<String, Any?>(),\n                        exc.localizedMessage\n                    )\n                }\n\n                override fun onImageSaved(output: ImageCapture.OutputFileResults) {\n                    if (output.savedUri == null) {\n                        if (file != null)\n                            mid = System.currentTimeMillis()\n                        val difference = (mid - begin) / 1000.toFloat()\n                        log(\"onImageSaved- \" + difference)\n                        addShootItem(file.path)\n                    } else {\n                        try {\n                            mid = System.currentTimeMillis()\n                            val difference = (mid - begin) / 1000.toFloat()\n                            log(\"onImageSaved2- \" + difference)\n                            var file = output.savedUri!!.toFile()\n                            addShootItem(file.path)\n                        } catch (ex: IllegalArgumentException) {\n                            pickIt?.getPath(output.savedUri, Build.VERSION.SDK_INT)\n                        }\n                    }\n                }\n            })\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        //Get Rotation Vector Sensor Values\n\n        if (event?.sensor?.type == Sensor.TYPE_ACCELEROMETER) {\n            System.arraycopy(\n                event.values,\n                0,\n                accelerometerReading,\n                0,\n                accelerometerReading.size\n            )\n        } else if (event?.sensor?.type == Sensor.TYPE_MAGNETIC_FIELD) {\n            System.arraycopy(event.values, 0, magnetometerReading, 0, magnetometerReading.size)\n        }\n\n        if (isSensorAvaliable && viewModel.showLeveler.value == true) {\n            updateOrientationAngles()\n        } else {\n            binding.flLevelIndicator.visibility = View.GONE\n        }\n    }\n\n    fun updateOrientationAngles() {\n        // Update rotation matrix, which is needed to update orientation angles.\n        SensorManager.getRotationMatrix(\n            rotationMatrix,\n            null,\n            accelerometerReading,\n            magnetometerReading\n        )\n\n        // \"rotationMatrix\" now has up-to-date information.\n\n        SensorManager.getOrientation(rotationMatrix, orientationAngles)\n\n        // \"orientationAngles\" now has up-to-date information.\n\n        //binding.tvAzimuth.text = \"Azimuth ${Math.toDegrees(orientationAngles[0].toDouble())}\"\n\n        val movearrow = abs(Math.toDegrees(orientationAngles[2].toDouble()).roundToInt()) - abs(\n            roll.roundToInt()\n        ) >= 1\n\n        val rotatedarrow =\n            abs(Math.toDegrees(orientationAngles[1].toDouble()).roundToInt()) - abs(\n                pitch.roundToInt()\n            ) >= 1\n\n\n        pitch = Math.toDegrees(orientationAngles[1].toDouble())\n        roll = Math.toDegrees(orientationAngles[2].toDouble())\n        azimuth = (orientationAngles[0] * 180 / Math.PI.toFloat()).toDouble()\n\n        binding.tvPitch?.text = \"Pitch : \" + pitch.roundToInt().toString()\n        binding.tvRoll?.text = \"Roll : \" + roll.roundToInt().toString()\n\n        binding.flLevelIndicator.updateGryoView(\n            roll,\n            pitch,\n            movearrow,\n            viewModel.desiredAngle,\n            rotatedarrow,\n            Utilities.getPreference(requireContext(),AppConstants.SELECTED_CATEGORY_ID)!!,\n            viewModel.hasEcomOverlay\n        )\n    }\n\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n    }\n\n\n    private fun getPreviewDimensions(view: View, type: Int) {\n        view.viewTreeObserver.addOnGlobalLayoutListener(object :\n            ViewTreeObserver.OnGlobalLayoutListener {\n            override fun onGlobalLayout() {\n                view.viewTreeObserver.removeOnGlobalLayoutListener(this)\n\n                when (type) {\n                    0 -> {\n                        val shootDimensions = ShootDimensions()\n                        shootDimensions.previewWidth = view.width\n                        shootDimensions.previewHeight = view.height\n\n                        viewModel.shootDimensions.value = shootDimensions\n\n                        binding.flTapToFocus.init(\n                            binding.viewFinder,\n                            cameraControl!!,\n                            cameraInfo!!,\n                            shootDimensions\n                        )\n                    }\n                }\n\n            }\n        })\n    }\n\n    private fun refreshText(){\n        binding.tvSkuN?.text=viewModel.sku?.skuName\n    }\n\n\n    private fun addShootItem(capturedImage: String) {\n        viewModel.showConfirmReshootDialog.value = true\n\n        if (viewModel.shootList.value == null) {\n            Utilities.hideProgressDialog()\n            Utilities.hideProgressDialog()\n            viewModel.shootList.value = ArrayList()\n        }\n\n        var sequenceNumber = viewModel.getSequenceNumber(\n            requireActivity().intent.getIntExtra(AppConstants.EXTERIOR_SIZE, 0),\n            requireActivity().intent.getIntExtra(AppConstants.INTERIOR_SIZE, 0),\n            requireActivity().intent.getIntExtra(AppConstants.MISC_SIZE, 0)\n        )\n\n        val debugData = JSONObject()\n        debugData.put(\"roll\", roll.roundToInt().unaryPlus())\n        debugData.put(\"pitch\", pitch.roundToInt().unaryPlus())\n\n        val shootData = ShootData(\n            capturedImage,\n            viewModel.sku?.projectUuid!!,\n            viewModel.sku?.uuid!!,\n            viewModel.categoryDetails.value?.imageType!!,\n            Utilities.getPreference(BaseApplication.getContext(), AppConstants.AUTH_KEY).toString(),\n            viewModel.overlayId,\n            sequenceNumber,\n            binding.flLevelIndicator.cameraAngle,\n            filename,\n            debugData.toString()\n        )\n\n        val item = viewModel.shootList.value!!.firstOrNull {\n            it.overlayId == viewModel.overlayId\n        }\n\n\n        if (viewModel.isReclick){\n            item?.capturedImage = capturedImage\n            item?.angle = binding.flLevelIndicator.cameraAngle\n            item?.name = filename\n        }else {\n            viewModel.shootList.value!!.add(shootData)\n        }\n\n        Log.d(TAG, \"addShootItem: \" + shootData.toProcessAt)\n\n        viewModel.shootList.value = viewModel.shootList.value\n\n        val properties = HashMap<String, Any?>()\n//        properties.apply {\n//            this[\"project_id\"] = viewModel.projectId.value!!\n//            this[\"sku_id\"] = viewModel.sku?.skuId!!\n//            this[\"image_type\"] = viewModel.categoryDetails.value?.imageType!!\n//        }\n\n        BaseApplication.getContext().captureEvent(Events.IMAGE_CAPTURED, properties)\n    }\n\n    override fun getViewModel() = ShootViewModel::class.java\n\n    override fun getFragmentBinding(\n        inflater: LayoutInflater,\n        container: ViewGroup?\n    ) = FragmentCameraBinding.inflate(inflater, container, false)\n\n    override fun PickiTonUriReturned() {\n\n    }\n\n\n    override fun PickiTonStartListener() {\n\n    }\n\n    override fun PickiTonProgressUpdate(progress: Int) {\n\n    }\n\n    override fun PickiTonCompleteListener(\n        path: String?,\n        wasDriveFile: Boolean,\n        wasUnknownProvider: Boolean,\n        wasSuccessful: Boolean,\n        Reason: String?\n    ) {\n        addShootItem(path!!)\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/spyneai/shoot/ui/base/CameraFragment.kt b/app/src/main/java/com/spyneai/shoot/ui/base/CameraFragment.kt
--- a/app/src/main/java/com/spyneai/shoot/ui/base/CameraFragment.kt	
+++ b/app/src/main/java/com/spyneai/shoot/ui/base/CameraFragment.kt	
@@ -639,7 +639,7 @@
                 if (viewModel.shootDimensions.value == null ||
                     viewModel.shootDimensions.value?.previewHeight == 0
                 ) {
-                    getPreviewDimensions(binding.viewFinder!!, 0)
+                    getPreviewDimensions(binding.viewFinder, 0)
                 }
             } catch (exc: Exception) {
                 Log.e(TAG, "Use case binding failed", exc)
Index: app/src/main/java/com/spyneai/shoot/ui/base/GyroView.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.spyneai.shoot.ui.base\n\nimport android.content.Context\nimport android.util.AttributeSet\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewTreeObserver\nimport android.view.animation.AccelerateInterpolator\nimport android.widget.FrameLayout\nimport androidx.core.content.ContextCompat\nimport com.spyneai.R\nimport com.spyneai.app.BaseApplication\nimport com.spyneai.dashboard.response.CameraSettings\nimport com.spyneai.databinding.GyroViewBinding\nimport com.spyneai.needs.AppConstants\nimport kotlin.math.abs\nimport kotlin.math.roundToInt\n\nclass GyroView : FrameLayout {\n\n    var binding: GyroViewBinding\n    private var topConstraint = 0\n    private var centerPosition = 0\n    private var bottomConstraint = 0\n    var isGyroOnCorrectAngle = false\n    var cameraAngle = 45\n    var angle = 0\n    var upcomingAngle = 0\n    var cameraSettings: CameraSettings? = null\n    //var cateoryName: String? = null\n    var cateoryOrientation: String? = null\n\n    constructor(context: Context) : this(context, null)\n    constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0)\n    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(\n        context,\n        attrs,\n        defStyleAttr\n    ) {\n\n        val view = LayoutInflater.from(context).inflate(\n            R.layout.gyro_view, null\n        )\n\n        this.addView(view)\n\n        binding = GyroViewBinding.bind(this)\n    }\n\n    //Todo: handle start method in record fragment\n    fun start(cateoryOrientation: String, cameraSettings: CameraSettings) {\n        this.cameraSettings = cameraSettings\n        this.cateoryOrientation = cateoryOrientation\n\n//        this.cateoryName?.let {\n//            if (cateoryName == \"Footwear\")\n//                binding.tvLevelIndicator.visibility = View.GONE\n//            else\n//                binding.flLevelIndicator.visibility = View.VISIBLE\n//        }\n\n        getPreviewDimensions(binding.ivGryroRing!!, 1)\n        getPreviewDimensions(binding.tvCenter!!, 2)\n    }\n\n    fun updateGryoView(\n        roll: Double,\n        pitch: Double,\n        movearrow: Boolean,\n        desiredAngle: Int = 0,\n        rotatedarrow: Boolean,\n        categoryId:String,\n        hasEcomOverlay:Boolean\n    ) {\n\n\n        when(cateoryOrientation){\n            \"portrait\" -> {\n                if(categoryId==AppConstants.FOOD_AND_BEV_CATEGORY_ID\n                    || hasEcomOverlay){\n\n                    if (binding.llTiltDown?.visibility == View.VISIBLE)\n                        binding.llTiltUp?.visibility = View.INVISIBLE\n                    else if (binding.llTiltUp?.visibility == View.VISIBLE)\n                        binding.llTiltDown?.visibility = View.INVISIBLE\n                    // angle name\n                    if (pitch.roundToInt() == 0 || (pitch.roundToInt() <= -0 && pitch.roundToInt() >= -3)&& desiredAngle == 0) {\n                        angle = 0\n                        binding.tvAngleValue!!.visibility = View.VISIBLE\n                        binding.tvAngleRed!!.visibility = View.INVISIBLE\n                        binding.llTiltDown?.visibility = View.INVISIBLE\n                        binding.llTiltUp?.visibility = View.INVISIBLE\n                    }else\n                        if (pitch.roundToInt() <= -82 && pitch.roundToInt() >= -88 && desiredAngle == 90) {\n                            angle = 90\n                            binding.tvAngleValue!!.visibility = View.VISIBLE\n                            binding.tvAngleRed!!.visibility = View.INVISIBLE\n                            binding.llTiltDown?.visibility = View.INVISIBLE\n                            binding.llTiltUp?.visibility = View.INVISIBLE\n                        }else\n                            if ((pitch.roundToInt() <= -40 && pitch.roundToInt() >= -45) && abs(roll.roundToInt()) < 100 && desiredAngle == 45) {\n                                angle = 45\n                                binding.tvAngleValue!!.visibility = View.VISIBLE\n                                binding.tvAngleRed!!.visibility = View.INVISIBLE\n                                binding.llTiltDown?.visibility = View.INVISIBLE\n                                binding.llTiltUp?.visibility = View.INVISIBLE\n                            }else {\n                                binding.tvAngleValue!!.visibility = View.INVISIBLE\n                                binding.tvAngleRed!!.visibility = View.VISIBLE\n\n                                if (desiredAngle == 90 && (pitch.roundToInt() <= -0 && pitch.roundToInt() >= -80)){\n                                    binding.llTiltUp?.visibility = View.VISIBLE\n                                    binding.llTiltDown?.visibility = View.INVISIBLE\n                                    binding.lottieDownArrow!!.visibility = View.INVISIBLE\n                                    binding.lottieUpArrow!!.visibility = View.INVISIBLE\n                                }\n                                else if (desiredAngle == 45 && (pitch.roundToInt() <= -0 && pitch.roundToInt() >= -39)){\n                                    binding.llTiltUp?.visibility = View.VISIBLE\n                                    binding.llTiltDown?.visibility = View.INVISIBLE\n                                    binding.lottieDownArrow!!.visibility = View.INVISIBLE\n                                    binding.lottieUpArrow!!.visibility = View.INVISIBLE\n                                }\n                                else if (desiredAngle == 45 && (pitch.roundToInt() <= -46 && pitch.roundToInt() >= -90)){\n                                    binding.llTiltDown?.visibility = View.VISIBLE\n                                    binding.llTiltUp?.visibility = View.INVISIBLE\n                                    binding.lottieDownArrow!!.visibility = View.INVISIBLE\n                                    binding.lottieUpArrow!!.visibility = View.INVISIBLE\n                                }\n                                else if (desiredAngle == 0 && (pitch.roundToInt() <= -0 && pitch.roundToInt() >= -90)){\n                                    binding.llTiltDown?.visibility = View.VISIBLE\n                                    binding.llTiltUp?.visibility = View.INVISIBLE\n                                    binding.lottieDownArrow!!.visibility = View.INVISIBLE\n                                    binding.lottieUpArrow!!.visibility = View.INVISIBLE}\n                                else if (desiredAngle == 0 && (pitch.roundToInt() >= 0 && pitch.roundToInt() <= 90)){\n                                    binding.llTiltUp?.visibility = View.VISIBLE\n                                    binding.llTiltDown?.visibility = View.INVISIBLE\n                                    binding.lottieDownArrow!!.visibility = View.INVISIBLE\n                                    binding.lottieUpArrow!!.visibility = View.INVISIBLE\n                                }\n                            }\n                    if (binding.flLevelIndicator.visibility == View.VISIBLE) {\n                        when (angle) {\n                            0 -> {\n                                binding.tvAngleValue!!.text = \"0\" + \"\\u00B0\"\n                                binding.tvAngleValue!!.visibility = View.VISIBLE\n                                binding.groupOverlay!!.visibility = View.GONE\n                                binding.ivBottomRight.visibility = View.VISIBLE\n                                binding.ivBottomLeft.visibility = View.VISIBLE\n                                binding.ivBottomRightSwiggy!!.visibility = View.GONE\n                                binding.ivBottomLeftSwiggy!!.visibility = View.GONE\n                            }\n                            45 -> {\n                                binding.tvAngleValue!!.text = \"45\" + \"\\u00B0\"\n                                binding.tvAngleValue!!.visibility = View.VISIBLE\n                                binding.groupOverlay!!.visibility = View.GONE\n                                binding.ivBottomRight.visibility = View.VISIBLE\n                                binding.ivBottomLeft.visibility = View.VISIBLE\n                                binding.ivBottomRightSwiggy!!.visibility = View.GONE\n                                binding.ivBottomLeftSwiggy!!.visibility = View.GONE\n                            }\n                            90 -> {\n                                binding.tvAngleValue!!.text = \"90\" + \"\\u00B0\"\n                                binding.tvAngleValue!!.visibility = View.VISIBLE\n\n\n                                if(categoryId!=AppConstants.FOOD_AND_BEV_CATEGORY_ID){\n                                    binding.groupOverlay!!.visibility = View.GONE\n                                    binding.ivBottomRightSwiggy!!.visibility = View.GONE\n                                    binding.ivBottomLeftSwiggy!!.visibility = View.GONE\n                                    binding.ivBottomRight.visibility = View.VISIBLE\n                                    binding.ivBottomLeft.visibility = View.VISIBLE\n\n                                }else {\n                                    binding.groupOverlay!!.visibility = View.VISIBLE\n                                    binding.ivBottomRightSwiggy!!.visibility = View.VISIBLE\n                                    binding.ivBottomLeftSwiggy!!.visibility = View.VISIBLE\n                                    binding.ivBottomRight.visibility = View.GONE\n                                    binding.ivBottomLeft.visibility = View.GONE\n                                }\n                            }\n                            else -> {\n                                binding.tvAngleValue!!.visibility = View.INVISIBLE\n                                binding.ivBottomRight.visibility = View.VISIBLE\n                                binding.ivBottomLeft.visibility = View.VISIBLE\n                                binding.ivBottomRightSwiggy!!.visibility = View.GONE\n                                binding.ivBottomLeftSwiggy!!.visibility = View.GONE\n                            }\n                        }\n                    }\n\n                    //hide moving line\n                    if (pitch.roundToInt() == 0 || (pitch.roundToInt() <= -0 && pitch.roundToInt() >= -3))\n                        binding.tvLevelIndicator.visibility = View.GONE\n                    else\n                        binding.tvLevelIndicator.visibility = View.VISIBLE\n\n\n                    when {\n                        (((pitch.roundToInt() == 0 || (pitch.roundToInt() <= 3 && pitch.roundToInt() >= -3))\n                                && (abs(roll.roundToInt()) <= 3 && abs(roll.roundToInt()) >= -3))&& desiredAngle == 0) -> {\n                            cameraSettings?.roll?.let {\n                                if (it.contains(0)) {\n                                    binding.lottieDownArrow!!.visibility = View.INVISIBLE\n                                    binding.lottieUpArrow!!.visibility = View.INVISIBLE\n                                    binding.tvUpcomingAngle1!!.visibility = View.INVISIBLE\n                                    binding.tvUpcomingAngle2!!.visibility = View.INVISIBLE\n                                    binding.tvAngleRed!!.visibility = View.INVISIBLE\n                                    isGyroOnCorrectAngle = true\n\n                                    if (pitch.roundToInt() == 0 || (pitch.roundToInt() <= -0 && pitch.roundToInt() >= -3)) {\n                                        cameraAngle = 0\n                                        gyroMeterOnLevel(false)\n                                    }\n                                }\n                            }\n                        }\n\n                        (pitch.roundToInt() <= -82 && pitch.roundToInt() >= -88 && desiredAngle == 90) -> {\n                            cameraSettings?.roll?.let {\n                                if (it.contains(90)) {\n                                    binding.lottieDownArrow!!.visibility = View.INVISIBLE\n                                    binding.lottieUpArrow!!.visibility = View.INVISIBLE\n                                    binding.tvUpcomingAngle1!!.visibility = View.INVISIBLE\n                                    binding.tvUpcomingAngle2!!.visibility = View.INVISIBLE\n                                    binding.tvAngleRed!!.visibility = View.INVISIBLE\n                                    isGyroOnCorrectAngle = true\n\n                                    cameraAngle = 90\n                                    gyroMeterOnLevel(true)\n                                }\n                            }\n                        }\n\n                        (pitch.roundToInt() <= -40 && pitch.roundToInt() >= -45 && desiredAngle == 45) -> {\n                            cameraSettings?.roll?.let {\n                                if (it.contains(45)) {\n                                    binding.lottieDownArrow!!.visibility = View.INVISIBLE\n                                    binding.lottieUpArrow!!.visibility = View.INVISIBLE\n                                    binding.tvUpcomingAngle1!!.visibility = View.INVISIBLE\n                                    binding.tvUpcomingAngle2!!.visibility = View.INVISIBLE\n                                    binding.tvAngleRed!!.visibility = View.INVISIBLE\n                                    isGyroOnCorrectAngle = true\n\n                                    cameraAngle = 45\n                                    gyroMeterOnLevel(false)\n                                }\n                            }\n                        }\n\n                        else -> {\n                            if (binding.flLevelIndicator.visibility == View.VISIBLE) {\n                                binding.lottieDownArrow!!.visibility = View.VISIBLE\n                                binding.lottieUpArrow!!.visibility = View.VISIBLE\n                                binding.tvAngleRed!!.visibility = View.VISIBLE\n                            }\n\n                            binding.tvAngleValue!!.visibility = View.INVISIBLE\n                            binding.groupOverlay!!.visibility = View.GONE\n                            binding.tvAngleValue!!.visibility = View.INVISIBLE\n                            binding.groupOverlay!!.visibility = View.GONE\n                            binding.ivBottomRightSwiggy!!.visibility = View.GONE\n                            binding.ivBottomLeftSwiggy!!.visibility = View.GONE\n                            binding.ivBottomRight.visibility = View.VISIBLE\n                            binding.ivBottomLeft.visibility = View.VISIBLE\n                            isGyroOnCorrectAngle = false\n                            val gyroAngle = (-pitch.roundToInt())\n\n                            binding.tvAngleRed!!.text = gyroAngle.toString() + \"\\u00B0\"\n                            gyroMeterOffLevel()\n\n                            if (movearrow) {\n                                if (abs(roll.roundToInt()) < 100) {\n                                    moveArrow((pitch + 85).unaryMinus())\n                                } else {\n                                    moveArrow(pitch + 85)\n                                }\n                            } else {\n                            }\n\n                            if (roll.roundToInt() == 1 || roll.roundToInt() == -1) {\n                                if (roll.roundToInt() == 1) {\n                                    rotateArrow((pitch + 85).unaryMinus().roundToInt())\n                                } else {\n                                    rotateArrow((pitch + 85).roundToInt())\n                                }\n                            }else{}\n                        }\n                    }\n\n                }\n                else{\n\n                    if (pitch.roundToInt() == 0 || (pitch.roundToInt() <= -0 && pitch.roundToInt() >= -3))\n                        angle = 0\n\n                    if (pitch.roundToInt() <= -82 && pitch.roundToInt() >= -88)\n                        angle = 90\n\n                    if ((pitch.roundToInt() <= -40 && pitch.roundToInt() >= -45) && abs(roll.roundToInt()) < 100)\n                        angle = 45\n\n                    if (binding.flLevelIndicator.visibility == View.VISIBLE) {\n                        when (angle) {\n                            0 -> {\n                                binding.tvAngleValue?.visibility = View.VISIBLE\n                                binding.tvAngleValue?.text = \"0\" + \"\\u00B0\"\n                                binding.groupOverlay?.visibility = View.GONE\n                            }\n                            45 -> {\n                                binding.tvAngleValue?.visibility = View.VISIBLE\n                                binding.tvAngleValue?.text = \"45\" + \"\\u00B0\"\n                                binding.groupOverlay?.visibility = View.GONE\n                            }\n                            90 -> {\n                                binding.tvAngleValue?.visibility = View.VISIBLE\n                                binding.tvAngleValue?.text = \"90\" + \"\\u00B0\"\n                                binding.groupOverlay?.visibility = View.GONE\n                            }\n                            else -> {\n                                binding.tvAngleValue?.visibility = View.INVISIBLE\n                                binding.groupOverlay?.visibility = View.GONE\n                            }\n                        }\n                    }\n\n                    //hide moving line\n                    if (pitch.roundToInt() == 0 || (pitch.roundToInt() <= -0 && pitch.roundToInt() >= -3))\n                        binding.tvLevelIndicator.visibility = View.GONE\n                    else\n                        binding.tvLevelIndicator.visibility = View.VISIBLE\n\n\n                    when {\n                        ((pitch.roundToInt() == 0 || (pitch.roundToInt() <= 3 && pitch.roundToInt() >= -3))\n                                && (abs(roll.roundToInt()) <= 3 && abs(roll.roundToInt()) >= -3)) -> {\n                            cameraSettings?.roll?.let {\n                                if (it.contains(0)) {\n                                    binding.lottieDownArrow!!.visibility = View.INVISIBLE\n                                    binding.lottieUpArrow!!.visibility = View.INVISIBLE\n                                    binding.tvUpcomingAngle1!!.visibility = View.INVISIBLE\n                                    binding.tvUpcomingAngle2!!.visibility = View.INVISIBLE\n                                    binding.tvAngleRed!!.visibility = View.INVISIBLE\n                                    isGyroOnCorrectAngle = true\n\n                                    if (pitch.roundToInt() == 0 || (pitch.roundToInt() <= -0 && pitch.roundToInt() >= -3)) {\n                                        cameraAngle = 0\n                                        gyroMeterOnLevel(false)\n                                    }\n                                }\n                            }\n                        }\n\n                        (pitch.roundToInt() <= -82 && pitch.roundToInt() >= -88) -> {\n                            cameraSettings?.roll?.let {\n                                if (it.contains(90)) {\n                                    binding.lottieDownArrow!!.visibility = View.INVISIBLE\n                                    binding.lottieUpArrow!!.visibility = View.INVISIBLE\n                                    binding.tvUpcomingAngle1!!.visibility = View.INVISIBLE\n                                    binding.tvUpcomingAngle2!!.visibility = View.INVISIBLE\n                                    binding.tvAngleRed!!.visibility = View.INVISIBLE\n                                    isGyroOnCorrectAngle = true\n\n                                    cameraAngle = 90\n                                    gyroMeterOnLevel(true)\n                                }\n                            }\n                        }\n\n                        (pitch.roundToInt() <= -40 && pitch.roundToInt() >= -45) -> {\n                            cameraSettings?.roll?.let {\n                                if (it.contains(45)) {\n                                    binding.lottieDownArrow!!.visibility = View.INVISIBLE\n                                    binding.lottieUpArrow!!.visibility = View.INVISIBLE\n                                    binding.tvUpcomingAngle1!!.visibility = View.INVISIBLE\n                                    binding.tvUpcomingAngle2!!.visibility = View.INVISIBLE\n                                    binding.tvAngleRed!!.visibility = View.INVISIBLE\n                                    isGyroOnCorrectAngle = true\n\n                                    cameraAngle = 45\n                                    gyroMeterOnLevel(false)\n                                }\n                            }\n                        }\n\n                        else -> {\n                            if (binding.flLevelIndicator.visibility == View.VISIBLE) {\n                                binding.lottieDownArrow!!.visibility = View.VISIBLE\n                                binding.lottieUpArrow!!.visibility = View.VISIBLE\n                                binding.tvAngleRed!!.visibility = View.VISIBLE\n                            }\n\n                            binding.tvAngleValue!!.visibility = View.INVISIBLE\n                            binding.groupOverlay!!.visibility = View.GONE\n                            binding.tvAngleValue!!.visibility = View.INVISIBLE\n                            isGyroOnCorrectAngle = false\n                            val gyroAngle = (-pitch.roundToInt())\n\n                            binding.tvAngleRed!!.text = gyroAngle.toString() + \"\\u00B0\"\n                            gyroMeterOffLevel()\n\n                            if (movearrow) {\n                                if (abs(roll.roundToInt()) < 100) {\n                                    moveArrow((pitch + 85).unaryMinus())\n                                } else {\n                                    moveArrow(pitch + 85)\n                                }\n                            } else {\n                            }\n\n                            if (roll.roundToInt() == 1 || roll.roundToInt() == -1) {\n                                if (roll.roundToInt() == 1) {\n                                    rotateArrow((pitch + 85).unaryMinus().roundToInt())\n                                } else {\n                                    rotateArrow((pitch + 85).roundToInt())\n                                }\n                            }else{}\n                        }\n                    }\n                }\n\n            }\n            else -> {\n                if(cameraSettings == null){\n                    return\n                }\n                when {\n                    roll > cameraSettings?.rollVar?.plus(90)\n                        ?.unaryMinus()!! && roll < (cameraSettings?.rollVar?.plus(70))?.unaryMinus()!! -> {\n                        cameraSettings?.roll?.let {\n                            if (it.contains(90)) {\n                                val rollMax =\n                                    cameraSettings?.rollVar?.plus(90)?.unaryMinus()\n                                val rollMin =\n                                    (cameraSettings?.rollVar?.plus(70))?.unaryMinus()\n\n                                val pitchMax = cameraSettings?.pitchVar?.plus(0)\n                                val pitchMin =\n                                    cameraSettings?.pitchVar?.minus(0)?.unaryMinus()\n\n\n                                if ((roll >= rollMax!! && roll <= rollMin!!) && (pitch >= pitchMin!! && pitch <= pitchMax!!)) {\n                                    gyroMeterOnLevel(true)\n                                } else {\n                                    gyroMeterOffLevel()\n\n                                    if (movearrow)\n                                        moveArrow(roll + 90)\n\n                                    if (rotatedarrow) {\n                                        if (pitch > 0) {\n                                            rotateArrow(pitch.minus(0).roundToInt())\n                                        } else {\n                                            rotateArrow(pitch.plus(0).roundToInt())\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else -> {\n                        gyroMeterOffLevel()\n\n                        if (movearrow)\n                            moveArrow(roll + 90)\n\n                        if (rotatedarrow) {\n                            if (pitch > 0) {\n                                rotateArrow(pitch.minus(0).roundToInt())\n                            } else {\n                                rotateArrow(pitch.plus(0).roundToInt())\n                            }\n                        } else {\n\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n\n    private fun gyroMeterOnLevel(removeAnimation: Boolean) {\n        isGyroOnCorrectAngle = true\n        if (removeAnimation) {\n            binding\n                .tvLevelIndicator\n                ?.animate()\n                ?.translationY(0f)\n                ?.setInterpolator(AccelerateInterpolator())?.duration = 0\n        }\n\n        binding.tvLevelIndicator?.rotation = 0f\n\n        binding.ivTopLeft?.setColorFilter(\n            ContextCompat.getColor(\n                BaseApplication.getContext(),\n                R.color.gyro_in_level\n            )\n        )\n        binding.ivBottomLeft?.setColorFilter(\n            ContextCompat.getColor(\n                BaseApplication.getContext(),\n                R.color.gyro_in_level\n            )\n        )\n\n        binding.ivGryroRing?.setColorFilter(\n            ContextCompat.getColor(\n                BaseApplication.getContext(),\n                R.color.gyro_in_level\n            )\n        )\n        binding.tvLevelIndicator?.background = ContextCompat.getDrawable(\n            BaseApplication.getContext(),\n            R.drawable.bg_gyro_level\n        )\n\n        binding.ivTopRight?.setColorFilter(\n            ContextCompat.getColor(\n                BaseApplication.getContext(),\n                R.color.gyro_in_level\n            )\n        )\n        binding.ivBottomRight?.setColorFilter(\n            ContextCompat.getColor(\n                BaseApplication.getContext(),\n                R.color.gyro_in_level\n            )\n        )\n    }\n\n    private fun rotateArrow(roundToInt: Int) {\n        binding.tvLevelIndicator?.rotation = roundToInt.toFloat()\n    }\n\n    private fun moveArrow(newRoll: Double) {\n        if (newRoll > 0 && (centerPosition + newRoll) < bottomConstraint) {\n            binding\n                .tvLevelIndicator\n                ?.animate()\n                ?.translationY(newRoll.toFloat())\n                ?.setInterpolator(AccelerateInterpolator())?.duration = 0\n        }\n\n        if (newRoll < 0 && (centerPosition - newRoll) > topConstraint) {\n            binding\n                .tvLevelIndicator\n                ?.animate()\n                ?.translationY(newRoll.toFloat())\n                ?.setInterpolator(AccelerateInterpolator())?.duration = 0\n        }\n    }\n\n    private fun gyroMeterOffLevel() {\n        isGyroOnCorrectAngle = false\n        binding.ivTopLeft?.setColorFilter(\n            ContextCompat.getColor(\n                BaseApplication.getContext(),\n                R.color.gyro_error_level\n            )\n        )\n        binding.ivBottomLeft?.setColorFilter(\n            ContextCompat.getColor(\n                BaseApplication.getContext(),\n                R.color.gyro_error_level\n            )\n        )\n\n        binding.ivGryroRing?.setColorFilter(\n            ContextCompat.getColor(\n                BaseApplication.getContext(),\n                R.color.gyro_error_level\n            )\n        )\n        binding.tvLevelIndicator?.background = ContextCompat.getDrawable(\n            BaseApplication.getContext(),\n            R.drawable.bg_gyro_error\n        )\n\n        binding.ivTopRight?.setColorFilter(\n            ContextCompat.getColor(\n                BaseApplication.getContext(),\n                R.color.gyro_error_level\n            )\n        )\n        binding.ivBottomRight?.setColorFilter(\n            ContextCompat.getColor(\n                BaseApplication.getContext(),\n                R.color.gyro_error_level\n            )\n        )\n    }\n\n    private fun getPreviewDimensions(view: View, type: Int) {\n        view.viewTreeObserver.addOnGlobalLayoutListener(object :\n            ViewTreeObserver.OnGlobalLayoutListener {\n            override fun onGlobalLayout() {\n                view.viewTreeObserver.removeOnGlobalLayoutListener(this)\n\n                when (type) {\n                    1 -> {\n                        topConstraint = view.top\n                        bottomConstraint = topConstraint + view.height\n                    }\n\n                    2 -> {\n                        centerPosition = view.top\n                    }\n                }\n            }\n        })\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/spyneai/shoot/ui/base/GyroView.kt b/app/src/main/java/com/spyneai/shoot/ui/base/GyroView.kt
--- a/app/src/main/java/com/spyneai/shoot/ui/base/GyroView.kt	
+++ b/app/src/main/java/com/spyneai/shoot/ui/base/GyroView.kt	
@@ -1,5 +1,6 @@
 package com.spyneai.shoot.ui.base
 
+import android.annotation.SuppressLint
 import android.content.Context
 import android.util.AttributeSet
 import android.view.LayoutInflater
@@ -32,6 +33,7 @@
 
     constructor(context: Context) : this(context, null)
     constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0)
+    @SuppressLint("InflateParams")
     constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(
         context,
         attrs,
